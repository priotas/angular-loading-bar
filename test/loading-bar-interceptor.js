// Generated by CoffeeScript 2.4.0
(function() {
  var flush, isLoadingBarInjected;

  isLoadingBarInjected = function(doc) {
    var divs, i, injected, j, len;
    injected = false;
    divs = angular.element(doc).find('div');
    for (j = 0, len = divs.length; j < len; j++) {
      i = divs[j];
      if (angular.element(i).attr('id') === 'loading-bar') {
        injected = true;
        break;
      }
    }
    return injected;
  };

  flush = null;

  describe('loadingBarInterceptor Service', function() {
    var $animate, $document, $http, $httpBackend, $timeout, endpoint, loadingBar, response, result;
    $http = $httpBackend = $document = $timeout = result = loadingBar = $animate = null;
    response = {
      message: 'OK'
    };
    endpoint = '/service';
    beforeEach(function() {
      module('ngAnimateMock', 'chieffancypants.loadingBar', function(cfpLoadingBarProvider) {
        loadingBar = cfpLoadingBarProvider;
      });
      result = null;
      inject(function(_$http_, _$httpBackend_, _$document_, _$timeout_, _$animate_) {
        $http = _$http_;
        $httpBackend = _$httpBackend_;
        $document = _$document_;
        $timeout = _$timeout_;
        return $animate = _$animate_;
      });
      // Angular 1.4 removed triggerCalbacks(), so try them both:
      return flush = function() {
        $animate.flush && $animate.flush();
        return $animate.triggerCallbacks && $animate.triggerCallbacks();
      };
    });
    
    beforeEach(function() {
      return jasmine.addMatchers({
        toBeBetween: {
          compare:function(high, low) {
            var temp;
            if (low > high) {
              temp = low;
              low = high;
              high = temp;
            }
            return this.actual > low && this.actual < high;
          }
        }
      });
    });

    afterEach(function() {
      $httpBackend.verifyNoOutstandingRequest();
      return $timeout.verifyNoPendingTasks();
    });
    it('should not increment if the response is cached in a cacheFactory', inject(function(cfpLoadingBar, $cacheFactory) {
      var cache;
      cache = $cacheFactory('loading-bar');
      $httpBackend.expectGET(endpoint).respond(response);
      $http.get(endpoint, {
        cache: cache
      }).then(function(data) {
        return result = data;
      }).catch(angular.noop);
      expect(cfpLoadingBar.status()).toBe(0);
      $timeout.flush();
      $timeout.flush();
      $httpBackend.flush(1);
      expect(cfpLoadingBar.status()).toBe(1);
      cfpLoadingBar.complete(); // set as complete
      $timeout.flush();
      flush();
      $http.get(endpoint, {
        cache: cache
      }).then(function(data) {
        return result = data;
      }).catch(angular.noop);
      // no need to flush $httpBackend since the response is cached
      expect(cfpLoadingBar.status()).toBe(0);
      $httpBackend.verifyNoOutstandingRequest();
      return $timeout.flush(); // loading bar is animated, so flush timeout
    }));
    it('should not increment if the response is cached using $http.defaults.cache', inject(function(cfpLoadingBar, $cacheFactory) {
      $http.defaults.cache = $cacheFactory('loading-bar');
      $httpBackend.expectGET(endpoint).respond(response);
      $http.get(endpoint).then(function(data) {
        return result = data;
      }).catch(angular.noop);
      expect(cfpLoadingBar.status()).toBe(0);
      $timeout.flush();
      $timeout.flush();
      $httpBackend.flush(1);
      expect(cfpLoadingBar.status()).toBe(1);
      cfpLoadingBar.complete(); // set as complete
      $timeout.flush();
      flush();
      $http.get(endpoint).then(function(data) {
        return result = data;
      }).catch(angular.noop);
      // no need to flush $httpBackend since the response is cached
      expect(cfpLoadingBar.status()).toBe(0);
      $httpBackend.verifyNoOutstandingRequest();
      return $timeout.flush(); // loading bar is animated, so flush timeout
    }));
    it('should not increment if the response is cached', inject(function(cfpLoadingBar) {
      $httpBackend.expectGET(endpoint).respond(response);
      $http.get(endpoint, {
        cache: true
      }).then(function(data) {
        return result = data;
      }).catch(angular.noop);
      expect(cfpLoadingBar.status()).toBe(0);
      $timeout.flush();
      $timeout.flush();
      $httpBackend.flush(1);
      expect(cfpLoadingBar.status()).toBe(1);
      cfpLoadingBar.complete(); // set as complete
      $timeout.flush();
      flush();
      $http.get(endpoint, {
        cache: true
      }).then(function(data) {
        return result = data;
      }).catch(angular.noop);
      // no need to flush $httpBackend since the response is cached
      expect(cfpLoadingBar.status()).toBe(0);
      $httpBackend.verifyNoOutstandingRequest();
      return $timeout.flush(); // loading bar is animated, so flush timeout
    }));
    it('should use default cache when $http.defaults.cache is true', inject(function(cfpLoadingBar, $cacheFactory) {
      // $http.defaults.cache = $cacheFactory('loading-bar')
      $http.defaults.cache = true;
      $httpBackend.expectGET(endpoint).respond(response);
      $http.get(endpoint).then(function(data) {
        return result = data;
      }).catch(angular.noop);
      expect(cfpLoadingBar.status()).toBe(0);
      $timeout.flush();
      $timeout.flush();
      $httpBackend.flush(1);
      expect(cfpLoadingBar.status()).toBe(1);
      cfpLoadingBar.complete(); // set as complete
      $timeout.flush();
      flush();
      $http.get(endpoint).then(function(data) {
        return result = data;
      }).catch(angular.noop);
      // no need to flush $httpBackend since the response is cached
      expect(cfpLoadingBar.status()).toBe(0);
      $httpBackend.verifyNoOutstandingRequest();
      return $timeout.flush(); // loading bar is animated, so flush timeout
    }));
    it('should not cache when the request is a POST', inject(function(cfpLoadingBar) {
      $httpBackend.expectPOST(endpoint).respond(response);
      $http.post(endpoint, {
        message: 'post'
      }).then(function(data) {
        return result = data;
      });
      expect(cfpLoadingBar.status()).toBe(0);
      $timeout.flush();
      $timeout.flush();
      $httpBackend.flush(1);
      expect(cfpLoadingBar.status()).toBe(1);
      $timeout.flush();
      flush();
      $httpBackend.expectPOST(endpoint).respond(response);
      $http.post(endpoint, {
        message: 'post'
      }).then(function(data) {
        return result = data;
      });
      expect(cfpLoadingBar.status()).toBe(0);
      $timeout.flush();
      $timeout.flush();
      $httpBackend.flush();
      expect(cfpLoadingBar.status()).toBe(1);
      return $timeout.flush();
    }));
    it('should increment the loading bar when not all requests have been recieved', inject(function(cfpLoadingBar) {
      $httpBackend.expectGET(endpoint).respond(response);
      $httpBackend.expectGET(endpoint).respond(response);
      $http.get(endpoint).then(function(data) {
        return result = data;
      }).catch(angular.noop);
      $http.get(endpoint).then(function(data) {
        return result = data;
      }).catch(angular.noop);
      expect(cfpLoadingBar.status()).toBe(0);
      $timeout.flush();
      $timeout.flush();
      $httpBackend.flush(1);
      expect(cfpLoadingBar.status()).toBe(0.5);
      $httpBackend.flush();
      expect(cfpLoadingBar.status()).toBe(1);
      return $timeout.flush(); // loading bar is animated, so flush timeout
    }));
    it('should count http errors as responses so the loading bar can complete', inject(function(cfpLoadingBar) {
      // $httpBackend.expectGET(endpoint).respond response
      $httpBackend.expectGET(endpoint).respond(401);
      $httpBackend.expectGET(endpoint).respond(401);
      $http.get(endpoint).catch(angular.noop);
      $http.get(endpoint).catch(angular.noop);
      expect(cfpLoadingBar.status()).toBe(0);
      $timeout.flush();
      $timeout.flush();
      $httpBackend.flush(1);
      expect(cfpLoadingBar.status()).toBe(0.5);
      $httpBackend.flush();
      expect(cfpLoadingBar.status()).toBe(1);
      return $timeout.flush();
    }));
    it('should insert the loadingbar into the DOM when a request is sent', inject(function(cfpLoadingBar) {
      $httpBackend.expectGET(endpoint).respond(response);
      $httpBackend.expectGET(endpoint).respond(response);
      $http.get(endpoint).catch(angular.noop);
      $http.get(endpoint).catch(angular.noop);
      $httpBackend.flush(1);
      $timeout.flush(); // flush the latencyThreshold timeout
      expect(isLoadingBarInjected($document.find(cfpLoadingBar.parentSelector))).toBe(true);
      $httpBackend.flush();
      return $timeout.flush();
    }));
    it('should insert the loadingbar as the last children of the parent container', inject(function(cfpLoadingBar) {
      var children, parent;
      $httpBackend.expectGET(endpoint).respond(response);
      $httpBackend.expectGET(endpoint).respond(response);
      $http.get(endpoint);
      $http.get(endpoint);
      $httpBackend.flush(1);
      $timeout.flush(); // flush the latencyThreshold timeout
      parent = $document.find(cfpLoadingBar.parentSelector)[0];
      children = parent.childNodes;
      expect(children[children.length - 1].id).toBe('loading-bar-spinner');
      expect(children[children.length - 2].id).toBe('loading-bar');
      $httpBackend.flush();
      return $timeout.flush();
    }));
    it('should remove the loading bar when all requests have been received', inject(function(cfpLoadingBar) {
      $httpBackend.expectGET(endpoint).respond(response);
      $httpBackend.expectGET(endpoint).respond(response);
      $http.get(endpoint).catch(angular.noop);
      $http.get(endpoint).catch(angular.noop);
      $httpBackend.flush(1);
      $timeout.flush(); // flush the latencyThreshold timeout
      expect(isLoadingBarInjected($document.find(cfpLoadingBar.parentSelector))).toBe(true);
      $httpBackend.flush();
      $timeout.flush();
      return expect(isLoadingBarInjected($document.find(cfpLoadingBar.parentSelector))).toBe(false);
    }));
    it('should get and set status', inject(function(cfpLoadingBar) {
      cfpLoadingBar.start();
      $timeout.flush();
      cfpLoadingBar.set(0.4);
      expect(cfpLoadingBar.status()).toBe(0.4);
      cfpLoadingBar.set(0.9);
      expect(cfpLoadingBar.status()).toBe(0.9);
      cfpLoadingBar.complete();
      return $timeout.flush();
    }));
    
    it('should increment things randomly', inject(function(cfpLoadingBar) {
      
      var lbar, width, width2;
      cfpLoadingBar.start();
      $timeout.flush();
      // increments between 3 - 6%
      cfpLoadingBar.set(0.1);
      lbar = angular.element(document.getElementById('loading-bar'));
      width = lbar.children().css('width').slice(0, -1);
      $timeout.flush();
      width2 = lbar.children().css('width').slice(0, -1);
      expect(width2).toBeGreaterThan(width);
      //expect(width2 - width).toBeBetween(3, 6);
      expect(width2 - width).toBeGreaterThan(3);
      expect(width2 - width).toBeLessThan(6);
      cfpLoadingBar.set(0.2);
      lbar = angular.element(document.getElementById('loading-bar'));
      width = lbar.children().css('width').slice(0, -1);
      $timeout.flush();
      width2 = lbar.children().css('width').slice(0, -1);
      expect(width2).toBeGreaterThan(width);
      //expect(width2 - width).toBeBetween(3, 6);
      expect(width2 - width).toBeGreaterThan(3);
      expect(width2 - width).toBeLessThan(6);
      // increments between 0 - 3%
      cfpLoadingBar.set(0.25);
      lbar = angular.element(document.getElementById('loading-bar'));
      width = lbar.children().css('width').slice(0, -1);
      $timeout.flush();
      width2 = lbar.children().css('width').slice(0, -1);
      expect(width2).toBeGreaterThan(width);
      //expect(width2 - width).toBeBetween(0, 3);
      expect(width2 - width).toBeGreaterThan(0);
      expect(width2 - width).toBeLessThan(3);
      cfpLoadingBar.set(0.5);
      lbar = angular.element(document.getElementById('loading-bar'));
      width = lbar.children().css('width').slice(0, -1);
      $timeout.flush();
      width2 = lbar.children().css('width').slice(0, -1);
      expect(width2).toBeGreaterThan(width);
      //expect(width2 - width).toBeBetween(0, 3);
      expect(width2 - width).toBeGreaterThan(0);
      expect(width2 - width).toBeLessThan(3);
      // increments between 0 - 2%
      cfpLoadingBar.set(0.65);
      lbar = angular.element(document.getElementById('loading-bar'));
      width = lbar.children().css('width').slice(0, -1);
      $timeout.flush();
      width2 = lbar.children().css('width').slice(0, -1);
      expect(width2).toBeGreaterThan(width);
      //expect(width2 - width).toBeBetween(0, 2);
      expect(width2 - width).toBeGreaterThan(0);
      expect(width2 - width).toBeLessThan(2);
      cfpLoadingBar.set(0.75);
      lbar = angular.element(document.getElementById('loading-bar'));
      width = lbar.children().css('width').slice(0, -1);
      $timeout.flush();
      width2 = lbar.children().css('width').slice(0, -1);
      expect(width2).toBeGreaterThan(width);
      //expect(width2 - width).toBeBetween(0, 2);
      expect(width2 - width).toBeGreaterThan(0);
      expect(width2 - width).toBeLessThan(2);
      // increments 0.5%
      cfpLoadingBar.set(0.9);
      lbar = angular.element(document.getElementById('loading-bar'));
      width = lbar.children().css('width').slice(0, -1);
      $timeout.flush();
      width2 = lbar.children().css('width').slice(0, -1);
      expect(width2).toBeGreaterThan(width);
      expect(width2 - width).toBe(0.5);
      cfpLoadingBar.set(0.97);
      lbar = angular.element(document.getElementById('loading-bar'));
      width = lbar.children().css('width').slice(0, -1);
      $timeout.flush();
      width2 = lbar.children().css('width').slice(0, -1);
      expect(width2).toBeGreaterThan(width);
      expect(width2 - width).toBe(0.5);
      // stops incrementing:
      cfpLoadingBar.set(0.99);
      lbar = angular.element(document.getElementById('loading-bar'));
      width = lbar.children().css('width').slice(0, -1);
      $timeout.flush();
      width2 = lbar.children().css('width').slice(0, -1);
      expect(width2).toBe(width);
      cfpLoadingBar.complete();
      return $timeout.flush();
    }));
    it('should not set the status if the loading bar has not yet been started', inject(function(cfpLoadingBar) {
      cfpLoadingBar.set(0.5);
      expect(cfpLoadingBar.status()).toBe(0);
      cfpLoadingBar.set(0.3);
      expect(cfpLoadingBar.status()).toBe(0);
      cfpLoadingBar.start();
      cfpLoadingBar.set(0.3);
      expect(cfpLoadingBar.status()).toBe(0.3);
      cfpLoadingBar.complete();
      return $timeout.flush();
    }));
    it('should broadcast started and completed events', inject(function(cfpLoadingBar, $rootScope) {
      var completedEventCalled, startedEventCalled;
      startedEventCalled = false;
      completedEventCalled = false;
      $rootScope.$on('cfpLoadingBar:started', function(event) {
        return startedEventCalled = true;
      });
      $rootScope.$on('cfpLoadingBar:completed', function(event) {
        return completedEventCalled = true;
      });
      expect(startedEventCalled).toBe(false);
      expect(completedEventCalled).toBe(false);
      cfpLoadingBar.start();
      expect(startedEventCalled).toBe(true);
      cfpLoadingBar.complete();
      $timeout.flush();
      return expect(completedEventCalled).toBe(true);
    }));
    it('should debounce the calls to start()', inject(function(cfpLoadingBar, $rootScope) {
      var startedEventCalled;
      startedEventCalled = 0;
      $rootScope.$on('cfpLoadingBar:started', function(event) {
        return startedEventCalled += 1;
      });
      cfpLoadingBar.start();
      expect(startedEventCalled).toBe(1);
      cfpLoadingBar.start();
      expect(startedEventCalled).toBe(1); // Should still be one, as complete was never called:
      cfpLoadingBar.complete();
      $timeout.flush();
      flush();
      cfpLoadingBar.start();
      expect(startedEventCalled).toBe(2);
      cfpLoadingBar.complete();
      return $timeout.flush();
    }));

    it('should ignore requests when ignoreLoadingBar is true', inject(function(cfpLoadingBar) {
      var injected;
      $httpBackend.expectGET(endpoint).respond(response);
      $http.get(endpoint, {
        ignoreLoadingBar: true
      }).catch(angular.noop);
      $httpBackend.flush();
      injected = isLoadingBarInjected($document.find(cfpLoadingBar.parentSelector));
      expect(injected).toBe(false);
      $timeout.flush();
    }));

    it('should ignore responses when ignoreLoadingBar is true (#70)', inject(function(cfpLoadingBar) {
      $httpBackend.expectGET(endpoint).respond(response);
      $httpBackend.expectGET('/service2').respond(response);
      $http.get(endpoint, {
        ignoreLoadingBar: true
      }).catch(angular.noop);
      $http.get('/service2').catch(angular.noop);
      expect(cfpLoadingBar.status()).toBe(0);
      $httpBackend.flush(1); // flush only the ignored request
      expect(cfpLoadingBar.status()).toBe(0);
      $timeout.flush();
      $httpBackend.flush();
      expect(cfpLoadingBar.status()).toBe(1);
      $timeout.flush(); // loading bar is animated, so flush timeout
    }));

    it('should ignore errors when ignoreLoadingBar is true (#70)', inject(function(cfpLoadingBar) {
      $httpBackend.expectGET(endpoint).respond(400);
      $httpBackend.expectGET('/service2').respond(400);
      $http.get(endpoint, {
        ignoreLoadingBar: true
      }).catch(angular.noop)
      $http.get('/service2').catch(angular.noop);
      expect(cfpLoadingBar.status()).toBe(0);
      $httpBackend.flush(1); // flush only the ignored request
      expect(cfpLoadingBar.status()).toBe(0);
      $timeout.flush();
      $httpBackend.flush();
      expect(cfpLoadingBar.status()).toBe(1);
      return $timeout.flush(); // loading bar is animated, so flush timeout
    }));
  });

  describe('LoadingBar only', function() {
    var $animate, $document, $timeout, cfpLoadingBar;
    cfpLoadingBar = $document = $timeout = $animate = null;
    beforeEach(function() {
      module('cfp.loadingBar', 'ngAnimateMock');
      return inject(function(_$http_, _$httpBackend_, _$document_, _$timeout_, _$animate_, _cfpLoadingBar_) {
        $timeout = _$timeout_;
        $document = _$document_;
        $animate = _$animate_;
        return cfpLoadingBar = _cfpLoadingBar_;
      });
    });
    
    it('should be capable of being used alone', function() {
      // just a simple quick test to make sure:
      cfpLoadingBar.start();
      $timeout.flush();
      // test setting progress
      cfpLoadingBar.set(0.4);
      expect(cfpLoadingBar.status()).toBe(0.4);
      // make sure it was injected into the DOM:
      expect(isLoadingBarInjected($document.find(cfpLoadingBar.parentSelector))).toBe(true);
      cfpLoadingBar.set(0.9);
      expect(cfpLoadingBar.status()).toBe(0.9);
      // test the complete call, which should remove it from the DOM
      cfpLoadingBar.complete();
      $timeout.flush();
      var doc = $document.find(cfpLoadingBar.parentSelector);
      expect(isLoadingBarInjected(doc)).toBe(false);
    });

    it('should start after multiple calls to complete()', function() {
      cfpLoadingBar.start();
      $timeout.flush();
      expect(isLoadingBarInjected($document.find(cfpLoadingBar.parentSelector))).toBe(true);
      cfpLoadingBar.complete();
      cfpLoadingBar.complete();
      cfpLoadingBar.start();
      $timeout.flush();
      expect(isLoadingBarInjected($document.find(cfpLoadingBar.parentSelector))).toBe(true);
      cfpLoadingBar.complete();
      $timeout.flush();
      //flush();
      expect(isLoadingBarInjected($document.find(cfpLoadingBar.parentSelector))).toBe(false);
    });
  });

  describe('Interceptor tests', function() {
    var $http, $httpBackend, $log, endpoint, provider, response;
    provider = $http = $httpBackend = $log = null;
    endpoint = '/service';
    response = {
      message: 'OK'
    };
    describe('Success response', function() {
      beforeEach(function() {
        module('chieffancypants.loadingBar', function($httpProvider) {
          provider = $httpProvider;
          provider.interceptors.push(function() {
            return {
              response: function(resp) {
                return null;
              }
            };
          });
        });
        return inject(function(_$http_, _$httpBackend_, _$log_) {
          $http = _$http_;
          $httpBackend = _$httpBackend_;
          return $log = _$log_;
        });
      });
      it('should detect poorly implemented interceptors and warn accordingly', function() {
        expect($log.error.logs.length).toBe(0);
        $httpBackend.expectGET(endpoint).respond(204);
        $http.get(endpoint).catch(angular.noop);
        $httpBackend.flush();
        expect($log.error.logs.length).toBe(1);
        return expect($log.error.logs).toContain(['Broken interceptor detected: Config object not supplied in response:\n https://github.com/chieffancypants/angular-loading-bar/pull/50']);
      });
    });
    
    describe('Error response', function() {
      beforeEach(function() {
        module('chieffancypants.loadingBar', function($httpProvider) {
          provider = $httpProvider;
          provider.interceptors.push(function($q) {
            return {
              responseError: function(resp) {
                delete resp.config;
                return $q.reject(resp);
              }
            };
          });
        });
        return inject(function(_$http_, _$httpBackend_, _$log_) {
          $http = _$http_;
          $httpBackend = _$httpBackend_;
          return $log = _$log_;
        });
      });
      return it('should detect poorly implemented interceptors and warn accordingly', function() {
        expect($log.error.logs.length).toBe(0);
        $httpBackend.expectGET(endpoint).respond(500);
        $http.get(endpoint).catch(angular.noop);
        $httpBackend.flush();
        expect($log.error.logs.length).toBe(1);
        return expect($log.error.logs).toContain(['Broken interceptor detected: Config object not supplied in rejection:\n https://github.com/chieffancypants/angular-loading-bar/pull/50']);
      });
    });
  });

}).call(this);
